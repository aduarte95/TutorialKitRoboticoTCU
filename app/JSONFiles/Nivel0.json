{
  "Nivel 0": {
    "Nombre": "Nivel 0",
    "Tarjetas": [
      {
        "Titulo": "Metas y Funcionamiento",
        "Descripcion": "<br><b> Metas </b></br> &bull; Aprender el funcionamiento básico de los materiales a utilizar en el kit. <br> &bull; Comprender la programación en Arduino mediante el programa Arduino IDE y por medio de bloques en Bitbloq.  <br> &bull; Conocer la estructura básica de una programación de Arduino, así como las distintas funciones para dar instrucciones. <br> &bull; Realizar ejercicios para visualizar el funcionamiento de los distintos materiales y estructuras creadas con estos, mediante un código de programación. <br><b>Funcionamiento </b></br> Los tutoriales básicos pretenden enseñar al alumno los conceptos básicos de programación en Arduino con el fin de que se comprenda la importancia de la programación, ya que esta representa en menor escala, la automatización que se puede reproducir en un futuro para cumplir diversos objetivos.",
        "Imagen": "images/micropiano.jpg",
        "Pasos": []
      },
      {
        "Titulo": "Actividades",
        "Descripcion": "Explicar los pasos básicos iniciales de introducción al programa Arduino IDE, así como la programación en bloques en el programa Bitbloq. <br> &bull; Comprender la estructura básica de la programación de Arduino mediante las funciones “setup” y “loop”. <br> &bull; Llevar a cabo el ejercicio de encender y apagar una LED. <br> &bull; Utilizar un servo, y posteriormente incorporarle a este un potenciómetro. <br> &bull; Observar el funcionamiento de una fotoresistencia mediante un ejercicio de lectura de luminosidad. <br> &bull; Realizar un ejercicio con un sensor ultrasónico de medición de distancias. <br> &bull; Para cada uno de los ejercicios, se cuenta con una breve explicación, las variables y funciones detalladas, el código tanto en Arduino IDE comentado, como por bloques, un diagrama de flujo de las operaciones secuenciales y lógicas que sigue la programación, y las instrucciones para armar las respectivas estructuras, acompañadas de su correspondiente esquema de conexiones eléctricas.",
        "Imagen": "images/micropiano.jpg",
        "Pasos": []
      }
    ]
  },
  "Ambientes de Desarrollo": {
    "Nombre": "Ambientes de Desarrollo",
    "Tarjetas": [
      {
        "Titulo:": "Arduino IDE",
        "Descripción": "<br><b> Pasos básicos iniciales – Arduino IDE </b></br> El software de código abierto Arduino IDE (Integrated Development Environment, o en español Entorno de Desarrollo Integrado) facilita escribir código y cargarlo en la placa de Arduino. Este IDE permite a los desarrolladores escribir código, configurar tableros y crear proyectos. Es decir, es una plataforma de hardware libre, basada en una placa con un microcontrolador y un entorno de desarrollo, diseñada para facilitar el uso de la electrónica en proyectos multidisciplinarios.",
        "Imagen": "",
        "Pasos": [
          {
            "Descripción": "<br>Conectar el Arduino Uno a la computadora mediante el cable USB.</br>",
            "Imagen": "images/Taller0/paso1Arduino.png"
          },
          {
            "Descripción": "<br> Abrir el programa Arduino IDE.</br> 1. VERIFICAR: Compila y aprueba el código. Atrapará los errores en la sintaxis (como los puntos y comas o paréntesis faltantes).<br> 2. CARGAR: Envía el código a la placa Arduino. Cuando se hace clic en él, se deberían ver las luces en el tablero parpadear rápidamente.<br> 3. NUEVO: Este botón abre una nueva pestaña de ventana de código.<br> 4. ABRIR: Este botón permitirá abrir un sketch existente. <br> 5. GUARDAR: Esto guarda el sketch actualmente activo. <br> 6. MONITOR DE SERIE: Esto abrirá una ventana que muestra cualquier información en serie que el Arduino está transmitiendo. Es muy útil para la depuración. <br> 7. NOMBRE DEL SKETCH: Esto muestra el nombre del sketch en el que se está trabajando actualmente. <br> 8. ÁREA DE CÓDIGO: Esta es el área donde se compone el código para el sketch. <br> 9. ÁREA DE MENSAJE: Aquí es donde el IDE indica si hubo algún error en el código. ",
            "Imagen": "images/Taller0/paso2Arduino.png"
          },
          {
            "Descripción": "<br> Seleccionar la placa: Arduino Uno. </br>",
            "Imagen": "images/Taller0/paso3Arduino.png"
          },
          {
            "Descripción": "<br> Seleccionar el puerto. </br>",
            "Imagen": "images/Taller0/paso4Arduino.png"
          },
          {
            "Descripcción": "<br><b> Estructura de un programa </b></br> La estructura básica en el lenguaje de programación de Arduino se compone de mínimo dos funciones específicas “setup” y “loop”. Ambas funciones encierran bloques que contienen declaraciones o instrucciones, como se muestra a continuación: <b> \n\nvoid setup ()\n{\ninstrucciones;\n}\nvoid loop ()\n{\ninstrucciones;\n}\n\n </b> Ambas funciones corren de manera automática cada vez que se enciende el Arduino o se reinicia, y son necesarias para que trabaje el programa.",
            "Imagen": ""
          },
          {
            "Descripción": "<br>&bull; <b> {} entre llaves </b> <br> Estas llaves “{}” tienen como objetivo definir el inicio y final de un bloque de instrucciones. Siempre deben aparecer ambas llaves, es decir, la de apertura y la de cierre; en caso contrario, el programa presenta errores. Para asegurarse de que cada llave de apertura tiene su correspondiente de cierre, se debe hacer clic en el punto de inserción de la llave abierta y de manera inmediata se marca la llave de cierre relacionada a ese bloque. <br> &bull; <b> ; punto y coma </b> <br> El punto y coma “;” es utilizado para separar instrucciones. En caso de olvidar poner fin a una línea con un punto y coma, se obtendrá un error en la compilación. <br> &bull; <b> // línea de comentario </b> <br> Para introducir un comentario o nota dentro del programa, se empieza la línea con “//”. Al escribirlo de esta manera, esa línea completa es ignorada por el programa (se encuentra deshabilitada). <br> Una línea de comentario es comúnmente utilizada después de una instrucción a manera de recordatorio sobre lo que hace esta. A manera de ejemplo se tiene:<br> <b>// esto es un comentario</b> <br> &bull; <b> /*…*/ bloque de comentarios </b> <br> Estos bloques de comentarios son áreas completas de texto que son ignoradas por el programa, es decir, está conformada por un conjunto de líneas de comentario. Un ejemplo de esto:<br> <b> /*\n esto es un bloque de comentario\nno olvidar cerrar siempre los comentarios\n*/</b></br>",
            "Imagen": ""
          },
          {
            "Descripción": "<br> <b> Variables </b> </br> <b> &bull; int: </b> <br> Enteros son un tipo de datos primarios que almacenan valores numéricos de 16 bits sin decimales comprendidos en el rango 32.767 hasta -32.768. <br> <b> int unaVariable </b> = 1500; // declara 'unaVariable' como una variable de tipo entero <br> <b>Nota:</b> Las variables de tipo entero “int” pueden sobrepasar su valor máximo o mínimo como consecuencia de una operación. Por ejemplo, si x = 32.767 y una posterior declaración agrega 1 a x, x = x + 1 entonces el valor se x pasará a ser -32.768. (algo así como que el valor da la vuelta). <br> <b> &bull; float </b> <br> El formato de dato del tipo “punto flotante” “float” se aplica a los números con decimales. Los números de punto flotante tienen una mayor resolución que los de 32 bits con un rango comprendido 3.4028235E +38 a +38-3.4028235E. <br> <b> float unaVariable = 3.14;</b> // declara 'unaVariable' como tipo flotante <br> <b> Nota: </b> Los números de punto flotante no son exactos, y pueden producir resultados extraños en las comparaciones. Los cálculos matemáticos de punto flotante son también mucho más lentos que los del tipo de números enteros, por lo que debe evitarse su uso si es posible. ",
            "Imagen": ""
          },
          {
            "Descripción": "<br> <b> Funciones </b> </br> Una “función” en el programa de Arduino es un bloque de código con un nombre y un conjunto de declaraciones o instrucciones que se ejecutan una vez que se llama a la función. <br> <b> &bull; void setup </b> <br> La función “setup” empieza a correr cuando se inicia el sketch o programa. Dentro de esta función se escribe todo lo que se requiera hacer una única vez inicial. Es utilizada para dar inicio al modo de trabajo de los pines o el puerto serie. Tiene que estar incluido en el programa aun cuando no exista una declaración que ejecutar. <br> <b> %bull; void loop </b> <br> Esta función se coloca y se corre después del “setup”. Es la función que lleva a cabo la mayor parte del trabajo. \nEl “loop” (en español conocido como “bucle”) corre las funciones establecidas, de manera cíclica sin parar o hasta que se toque el botón de reinicio “Reset” o se apague el Arduino.<br> <b> &bull; pinMode (pin, modo) </b> <br> El Arduino tiene 13 pines digitales que se pueden usar como Entradas o Salidas (INPUT/OUTPUT). Para poder establecer si el pin es una entrada o salida, se utiliza la función pinMode (pin, modo), donde “pin” y “modo” corresponden a dos argumentos, respectivamente al número del pin que se va a utilizar y si este es OUTPUT o INTPUT. Esta instrucción se utiliza en la parte de configuración setup (). <br> <b>Nota:</b> Los terminales de Arduino, por defecto, están configurados como entradas, por lo tanto, no es necesario definirlos en el caso de que vayan a trabajar como entradas.<br> <b> void setup ()\n{\npinMode (13, OUTPUT); // se establece el pin 13 como una salida\n}</b> <br> <b> &bull; digitalWrite (pin, valor)</b> <br>La función digitalWrite (pin, valor) envía al número de pin definido (pin) como OUTPUT, el valor de “HIGH” o “LOW” (valor), lo cual pone en 1 (alto) o 0 (bajo) la salida. El pin se puede especificar ya sea como una variable o como una constante (0-13). Se muestra a continuación un ejemplo:<br> <b>void loop ()\n{\ndigitalWrite (13, HIGH); // se tiene en el pin 13 un valor de HIGH (alto o 1)\n}</b> <br> <b> &bull; delay (ms) </b> <br> Esta función detiene la ejecución del programa, o la pone en pausa, por un tiempo determinado en milisegundos (ms). De esta manera se tiene por ejemplo que 1000 milisegundos equivalen a 1 segundo. Como ejemplo se tiene: <br> <b>void loop ()\n{\ndelay (1000); // espera de 1 segundo\n}</b>  <br> <b> &bull; Serial.begin (velocidad) </b> <br> Abre el puerto serie y fija la velocidad en baudios para la transmisión de datos en serie. El valor típico de velocidad para comunicarse con el ordenador es 9600, aunque otras velocidades pueden ser soportadas.\n\nvoid setup ()\n{\nSerial.begin (9600); // abre el Puerto serie\n} // configurando la velocidad en 9600 bps  <br> <b> &bull; analogRead (pin) </b> <br> Lee el valor de un determinado pin definido como entrada analógica con una resolución de 10 bits. Esta instrucción sólo funciona en los pines (0-5). El rango de valor que podemos leer oscila de 0 a 1023.\n\nvalor = analogRead (pin); // asigna a valor lo que lee en la entrada ´pin'\n\nNota: Los pins analógicos (0-5) a diferencia de los pines digitales, no necesitan ser declarados como INPUT u OUPUT ya que son siempre INPUT. <br> <b> &bull; Serial.printIn (data) </b> <br> Imprime los datos en el puerto serie, seguido por un retorno de carro automático y salto de línea. Este comando toma la misma forma que Serial.print (), pero es más fácil para la lectura de los datos en el Monitor Serie del software.\n\nSerial.println (analogValue); // envía el valor 'analogValue' al puerto\n\nEl siguiente ejemplo toma de una lectura analógica pin 0 y envía estos datos al ordenador cada 1 segundo.\n\nvoid setup ()\n{\nSerial.begin (9600); // configura el puerto serie a 9600bps\n}\nvoid loop ()\n{\nSerial.println (analogRead (0)); // envía valor analógico\ndelay (1000); // espera 1 segundo\n}\n  <br> <b> for (inicialización; condición; expresión) </b> <br> La declaración for se usa para repetir un bloque de sentencias encerradas entre llaves un número determinado de veces. Cada vez que se ejecutan las instrucciones del bucle se vuelve a testear la condición. La declaración for tiene tres partes separadas por (;) vemos el ejemplo de su sintaxis:\n\nfor (inicialización; condición; expresión)\n{\nejecutaInstrucciones;\n}\n\nLa inicialización de una variable local se produce una sola vez y la condición se testea cada vez que se termina la ejecución de las instrucciones dentro del bucle. Si la condición sigue cumpliéndose, las instrucciones del bucle se vuelven a ejecutar. Cuando la condición no se cumple, el bucle termina. \n\nEl siguiente ejemplo inicia el entero i en el 0, y la condición es probar que el valor es inferior a 20 y si es cierto i se incrementa en 1 y se vuelven a ejecutar las instrucciones que hay dentro de las llaves:\n\nfor (int i=0; i<20; i++) // declara i, prueba que es menor que 20, incrementa i en 1\n{\ndigitalWrite (13, HIGH); // envía un 1 al pin 13\ndelay (1000); // espera 1 seg.\ndigitalWrite (13, LOW); // envía un 0 al pin 13\ndelay (1000); // espera 1 seg.\n}\n <br> <b> write () </b> <br> Escribe datos binarios en el puerto serie. Estos datos se envían como un byte o una serie de bytes; para enviar los caracteres que representan los dígitos de un número, utilice la función print () en su lugar.<br> <b>map (valor, fromLow, fromHigh, toLow, toHigh) </b> <br> Re-mapea un número de un rango a otro. Es decir, un valor de fromLow se asignaría a toLow, un valor de fromHigh a toHigh, valores intermedios a valores intermedios, etc. No restringe los valores dentro del rango, porque los valores fuera del rango a veces son útiles. Los parámetros son los siguientes:\n\nvalor: el número a mapear\nfromLow: el límite inferior del rango actual del valor\nfromHigh: el límite superior del rango actual del valor\ntoLow: el límite inferior del rango objetivo del valor\ntoHigh: el límite superior del rango objetivo del valor. <br> <b>if</b> <br> if es un estamento que se utiliza para probar si una determinada condición se ha alcanzado, como por ejemplo averiguar si un valor analógico está por encima de un cierto número, y ejecutar una serie de declaraciones (operaciones) que se escriben dentro de llaves, si es verdad. Si es falso (la condición no se cumple) el programa salta y no ejecuta las operaciones que están dentro de las llaves. El formato para if es el siguiente:\n\nif (unaVariable ?? valor)\n{\nejecutaInstrucciones;\n}\n<br>En el ejemplo anterior se compara una variable con un valor, el cual puede ser una variable o constante. Si la comparación, o la condición entre paréntesis se cumple (es cierta), las declaraciones dentro de los corchetes se ejecutan. Si no es así, el programa salta sobre ellas y sigue.<br> <b>Nota:<b> Tenga en cuenta el uso especial del símbolo '=', poner dentro de if (x = 10), podría parecer que es válido, pero sin embargo no lo es ya que esa expresión asigna el valor 10 a la variable x, por eso dentro de la estructura if se utilizaría X==10 que en este caso lo que hace el programa es comprobar si el valor de x es 10. Ambas cosas son distintas por lo tanto dentro de las estructuras if, cuando se pregunte por un valor se debe poner el signo doble de igual “==”",
            "Imagen": "images/Taller0/paso3Arduino.png"
          }
        ]
      },
      {
        "Titulo:": "Bitbloq",
        "Descripcción": "<br><b> Pasos básicos iniciales – Bitbloq </b></br> Bitbloq es una herramienta online que permite crear programas para un microcontrolador y cargarlos en el mismo de forma sencilla y sin tener necesariamente conocimientos de programación. Es de código abierto y puede usarse de forma gratuita, se requiere de un explorador basado en Chromium (Google Chrome, por ejemplo) para acceder a la herramienta.",
        "Imagen": "",
        "Pasos": [
          {
            "Descripción": "<br>Crear una cuenta en Bitbloq, todo es almacenado en la nube, puede ser compartido con otras cuentas o descargado para tener un respaldo local.</br>",
            "Imagen": "images/Taller0/parte1Bitbloq.png"
          },
          {
            "Descripción": "<br>Página principal – Crear proyecto: La página principal muestra todos los proyectos asociados a una cuenta y permite la creación de nuevos proyectos. </br> ",
            "Imagen": "images/Taller0/parte2Bitbloq.png"
          },
          {
            "Descripción": "<br> Al seleccionar “Nuevo proyecto” la página te redirige a un proyecto en blanco, es una buena práctica darle al proyecto un nombre apropiado haciendo clic sobre “Proyecto sin título”,  los proyectos tienen tres secciones principales que pueden accederse en los íconos al lado izquierdo de la pantalla. Las secciones son hardware, en donde se seleccionan los componentes a utilizar, la sección software, en donde se crea el código de nuestro proyecto y la sección de información, en esta se le da una descripción al proyecto, se puede agregar un video del proyecto y cambiar los colores de los bloques de programación (opcional). </br>",
            "Imagen": "images/Taller0/parte3Bitbloq.png"
          },
          {
            "Descripción": "<br> Una vez creado un proyecto lo primero que debe hacerse es agregar el microcontrolador a ser usado en el proyecto (en la sección “Placas”) para agregarlo solo debe arrastrarlo al área de trabajo, en el caso del Robokit se hace uso de un Arduino Uno, luego deben conectarse a este todos los componentes a usar en el proyecto (sección “Componentes”). </br>",
            "Imagen": "images/Taller0/parte4Bitbloq.png"
          },
          {
            "Descripción": "<br> Una vez que todos los componentes están conectados a la placa, pasamos a la sección de software, en esta puede trabajarse mediante bloques o código de programación y también puede iniciar un proyecto en bloques y luego cambiar unos detalles en el código. El código se divide en tres secciones al igual que en un programa de código (ver sección “Estructura de un programa”) y en el panel derecho están todos los comandos que pueden ser agregados al código representados por bloques. </br>",
            "Imagen": "images/Taller0/parte5Bitbloq.png"
          },
          {
            "Descripción": "<br> En la sección componentes aparecen todos los dispositivos que conectamos al Arduino en la sección de hardware, nótese que ciertos bloques usados en estos tutoriales se acceden haciendo clic en “Avanzados”, las demás secciones son equivalentes a lo expuesto en la sección de “Estructura de un programa”; para cargar un programa solamente debe hacer clic en la flecha en la parte superior derecha. </br>",
            "Imagen": "images/Taller0/parte6Bitbloq.png"
          }

        ]
      }
    ]
  },
  "Practica": {
    "Nombre": "Practica",
    "Tarjetas": [
      {
        "Titulo": "Encender una LED",
        "Descripcción": "<br><b> Encender una LED </b></br> Para realizar el ejercicio de encender una LED, se hace uso de los pines digitales. Estos son 13 en total y pueden ser OUTPUT o INPUT, señales que a su vez van a encontrarse encendidas (ON) o apagadas (OFF). <br> &bull; Si la señal se encuentra HIGH, está ON, lo que indica que está recibiendo 5 voltios. <br> &bull; Si la señal se encuentra en LOW, está OFF, es decir, recibiendo 0 voltios. <br> &bull; Es necesario utilizar resistencias entre los LED y el Arduino para que estos no se quemen debido a que hay demasiada corriente para ellos.",
        "Imagen": "",
        "Pasos": [
          {
            "Descripción": "<br> <b> Diagrama de flujo  </b> <br> ",
            "Imagen": "images/Taller0/paso1EncenderLed.jpg"
          },
          {
            "Descripción": "<br> <b> Instrucciones para armar la estructura </b> </br> &bull; Conectar un LED y una resistencia al pin 13. <br> a. La pata corta del LED se conecta a la resistencia de 330 OHMS. <br> b. La pata larga del LED se conecta a tierra (GRND). <br> c. El otro extremo de la resistencia se conecta al pin 13. ",
            "Imagen": ""
          },
          {
            "Descripción": "<br> <b> Esquema de conexiones eléctricas </b> </br> ",
            "Imagen": "images/Taller0/paso3EncenderLed.png"
          },
          {
            "Descripción": "<br> <b> Código en Arduino IDE </b> </br> const int led = 13; // se declara el pin 13 como un entero constante llamado “led”\n\nvoid setup ()\n{\npinMode (led, OUTPUT); // se establece el pin 13 como una salida\n}\n\nvoid loop ()\n{\ndigitalWrite (led, HIGH); // la LED se enciende\ndelay (1000); // espera de 1 segundo\ndigitalWrite (led, LOW); // la LED se apaga\ndelay (1000); // espera de 1 segundo\n}\n",
            "Imagen": "images/Taller0/paso3Arduino.png"
          },
          {
            "Descripción": "<br> <b> Código en Bitbloq </b> </br> ",
            "Imagen": "images/Taller0/paso5EncenderLed.png"
          }
        ]
      },
      {
        "Titulo": "Lectura de luminosidad",
        "Descripcción": "<br><b> Lectura de luminosidad </b></br> Se realiza un ejercicio simple con una fotoresistencia, la cual va a medir un valor de luminosidad. Explicación de la variable de tipo float, y las funciones Serial.begin (velocidad), analogRead (pin) y Serial.printIn (data). Para finalizar se realiza el ejercicio de lectura de luminosidad, donde se puede observar el valor leído por la fotoresistencia en el monitor serial de la computadora.",
        "Imagen": "",
        "Pasos": [
          {
            "Descripción": "<br> <b> Diagrama de flujo  </b> <br> ",
            "Imagen": "images/Taller0/paso1Luminosidad.jpg"
          },
          {
            "Descripción": "<br> <b> Instrucciones para armar la estructura </b> </br> &bull; Conectar circuito de energía a riel lateral del breadboard (la mayoría de los proyectos requieren de este circuito para conectar más de un componente, ya sea sensor o actuador).<br> a. Conectar la salida de 5V al riel marcado como positivo en el breadboard. <br> b. Conectar cualquiera de las tres tierras (GRND) al riel marcado como negativo en el breadboard. <br> &bull; Conectar el fotorresistor.<br> a. Se deben conectar ambos extremos de la fotorresistencia a canales distintos del breadboard. <br> b. Conectar a uno de estos canales el riel de 5V. <br> c. El otro canal debe conectarse a una resistencia y esta a la tierra.<br> d. Este canal debe a su vez conectarse a uno de los pines análogos del Arduino (en el caso del ejemplo al pin A5).",
            "Imagen": ""
          },
          {
            "Descripción": "<br> <b> Esquema de conexiones eléctricas </b> </br> ",
            "Imagen": "images/Taller0/paso3Luminosidad.png"
          },
          {
            "Descripción": "<br> <b> Código en Arduino IDE </b> </br> const int sensor_de_luz = A5;\nfloat Luminosidad = 0; \n/*\nesto genera una variable llamada luminosidad en la que almacenaremos el valor que lee el sensor\n*/\n\nvoid setup () {\n\tpinMode (sensor_de_luz; INPUT);\n\tSerial.begin(9600);\n}\n\nvoid loop () { \n\tLuminosidad = analogRead (sensor_de_luz); \n/*\nse le asigna el valor medio de luz a la variable luminosidad\n*/\nSerial.println(Luminosidad);\n/*\nSe envía el valor a la computadora, puede leerse con el monitor serial\n*/\ndelay (500):\n}\n",
            "Imagen": ""
          },
          {
            "Descripción": "<br> <b> Código en Bitbloq </b> </br> ",
            "Imagen": "images/Taller0/paso3Luminosidad.png"
          }
        ]
      },
      {
        "Titulo": "Control del servo – barrido",
        "Descripcción": "<br><b> Control del servo </b></br> Para la parte 3 el ejercicio consiste en la utilización de un servo, con el cual se hace un barrido en un rango de ángulo de 180 grados. En este caso se da la descripción de nuevas funciones tales como #include <librería>, utilizando la librería de Servo, la cual también es explicada, además las funciones de attach (), for (inicialización; condición; expresión), y write (). <br><b> Funciones </b></br> @bull; <b> #include <librería> </b> <br> #include se utiliza para incluir librerías externas en el sketch. Esto le da al programador acceso a un gran grupo de librerías estándar (grupos de funciones prefabricadas), y también a librerías escritas especialmente para Arduino. <br> <b>Servo.h</b> <br> Esta librería permite que una placa Arduino controle los servomotores. Los servos tienen engranajes integrados y un eje que se puede controlar con precisión. Los servos estándar permiten que el eje se coloque en varios ángulos, generalmente entre 0 y 180 grados. Los servos de rotación continua permiten que la rotación del eje se ajuste a varias velocidades. La librería Servo admite hasta 12 motores en la mayoría de las placas Arduino. <br> <b>attach ()</b> <br> Adjunta la variable Servo a un pin. La librería Servo admite servos en solo dos pines: 9 y 10. ",
        "Imagen": "",
        "Pasos": [
          {
            "Descripción": "<br> <b> Diagrama de flujo  </b> <br> ",
            "Imagen": "images/Taller0/paso1ServoBarrido.jpg"
          },
          {
            "Descripción": "<br> <b> Instrucciones para armar la estructura </b> </br> &bull; Conectar el servo al Arduino.<br> a. Conectar el cable central al pin de 5V.<br> b. Conectar el cable lateral con color más opaco a la tierra.<br> c. Conectar el cable restante a un pin digital (en el caso del ejemplo al pin 10).",
            "Imagen": ""
          },
          {
            "Descripción": "<br> <b> Esquema de conexiones eléctricas </b> </br> ",
            "Imagen": "images/Taller0/paso3ServoBarrido.png"
          },
          {
            "Descripción": "<br> <b> Código en Arduino IDE </b> </br> #include <Servo.h>\nServo servo;\nfloat Grados = 0; // se declara una variable para los grados del servo\n\nvoid setup () { \n\tservo.attach (10);\n}\n\nvoid loop () {\n\tfor (Grados = 0; Grados <= 180; Grados += 1) {\n\t\tservo.write (Grados);\n\t\tdelay (19);\n\t}\n\tfor (Grados = 180; Grados >= 0; Grados -= 1) {\n\t\tservo.write (Grados);\n\t\tdelay (19);\n\t}\n}\n",
            "Imagen": ""
          },
          {
            "Descripción": "<br> <b> Código en Bitbloq </b> </br> ",
            "Imagen": "images/Taller0/paso4ServoBarrido.png"
          }
        ]
      },
      {
        "Titulo": "Control del servo – potenciómetro",
        "Descripcción": "<br><b> Control del servo </b></br> En este caso se explica una nueva función de map (valor, fromLow, fromHigh, toLow, toHigh), la cual es utilizada para poner en funcionamiento el potenciómetro y con este controlar el barrido del servo. <br><b> Funciones </b></br> @bull; <b> #include <librería> </b> <br> #include se utiliza para incluir librerías externas en el sketch. Esto le da al programador acceso a un gran grupo de librerías estándar (grupos de funciones prefabricadas), y también a librerías escritas especialmente para Arduino. <br> <b>Servo.h</b> <br> Esta librería permite que una placa Arduino controle los servomotores. Los servos tienen engranajes integrados y un eje que se puede controlar con precisión. Los servos estándar permiten que el eje se coloque en varios ángulos, generalmente entre 0 y 180 grados. Los servos de rotación continua permiten que la rotación del eje se ajuste a varias velocidades. La librería Servo admite hasta 12 motores en la mayoría de las placas Arduino. <br> <b>attach ()</b> <br> Adjunta la variable Servo a un pin. La librería Servo admite servos en solo dos pines: 9 y 10. ",
        "Imagen": "",
        "Pasos": [
          {
            "Descripción": "<br> <b> Diagrama de flujo  </b> <br> ",
            "Imagen": "images/Taller0/paso1ServoPotenciometro.jpg"
          },
          {
            "Descripción": "<br> <b> Instrucciones para armar la estructura </b> </br> &bull; Conectar circuito de energía a riel lateral del breadboard. <br> a. Conectar la salida de 5V al riel marcado como positivo en el breadboard.<br> b. Conectar cualquiera de las tres tierras (GRND) al riel marcado como negativo en el breadboard. <br> &bull; Conectar el servo al Arduino<br> a. Conectar el cable central al riel de 5V. <br> b. Conectar el cable lateral con color más opaco a la tierra. <br> c. Conectar el cable restante a un pin digital (en el caso del ejemplo al pin 10). <br> &bull; Conectar el potenciómetro <br> a. La salida central del potenciómetro debe conectarse a un pin análogo (en el ejemplo el pin A0). <br> b. Los pines laterales se deben conectar uno al riel de 5V y el otro a la tierra (no importa cuál va a cuál).",
            "Imagen": ""
          },
          {
            "Descripción": "<br> <b> Esquema de conexiones eléctricas </b> </br> ",
            "Imagen": "images/Taller0/paso3ServoPotenciometro.png"
          },
          {
            "Descripción": "<br> <b> Código en Arduino IDE </b> </br> #include <Servo.h>\nconst int potenciometro = A0;\nServo servo;\nfloat Potenciometro = 0;\nfloat Grados = 0;\n\n/*\ndeclaramos dos variables, una para la lectura del potenciómetro y otra para los grados del servo\n*/\n\nvoid setup () { \n\tpinMode (potenciometro, INPUT);\nservo.attach (10);\n}\nvoid loop () {\n\tPotenciometro = analogRead (potenciometro);\n\tGrados = map (Potenciometro, 0, 1023, 0, 180);\n\n\t/*\nel valor del potenciómetro debe ser transformado a grados que debe moverse el servo usando la función map () o “mapear”, en este caso de 0 a 180 grados\n\t*/\n\n\tservo.write (Grados);\n}\n",
            "Imagen": ""
          },
          {
            "Descripción": "<br> <b> Código en Bitbloq </b> </br> ",
            "Imagen": "images/Taller0/paso4ServoPotenciometro.png"
          }
        ]
      },
      {
        "Titulo": "Control del servo – distancia",
        "Descripcción": "<br><b> Control del servo </b></br> Como último ejercicio para el taller de tutoriales básicos, se conecta un circuito para utilizar un servo, esta vez haciendo uso de sensores ultrasónicos, los cuales permiten identificar la distancia a la cual se encuentra un objeto de estos y de acuerdo a esta, que el servo siga las instrucciones establecidas en el código de programación. Se explican las funciones de hc.dist () y la función condicional if (), así como el objeto controlador del ultrasonido HCSR04 (pin Trig, Echo) y la librería HCSR04.h. <br><b> Funciones </b></br> @bull; <b> #include <librería> </b> <br> #include se utiliza para incluir librerías externas en el sketch. Esto le da al programador acceso a un gran grupo de librerías estándar (grupos de funciones prefabricadas), y también a librerías escritas especialmente para Arduino. <br> <b>Servo.h</b> <br> Esta librería permite que una placa Arduino controle los servomotores. Los servos tienen engranajes integrados y un eje que se puede controlar con precisión. Los servos estándar permiten que el eje se coloque en varios ángulos, generalmente entre 0 y 180 grados. Los servos de rotación continua permiten que la rotación del eje se ajuste a varias velocidades. La librería Servo admite hasta 12 motores en la mayoría de las placas Arduino. <br> <b>attach ()</b> <br> Adjunta la variable Servo a un pin. La librería Servo admite servos en solo dos pines: 9 y 10. <br> <b>HCSR04.h</b> <br> Para este ejercicio se utiliza un medidor de distancias a través de ultrasonidos HC-SR04. Es por lo que se incluye la librería HCSR04.h con el fin de contar con las funciones pertenecientes a esta para el control del sensor ultrasónico utilizado. Dichas funciones van a permitir identificar si en frente hay un obstáculo y a que distancia se encuentra. <br> <b>HCSR04 hc (pin Trig, pin Echo) </b> <br> La interfaz del sensor HC-SR04 y Arduino se logra mediante 2 pines digitales: el pin de disparo (trigger) y eco (echo). La función de cada uno de estos pines es la siguiente:\nEl pin trigger recibe un pulso de habilitación de parte del microcontrolador, mediante el cual se le indica al módulo que comience a realizar la medición de distancia.\nEn el pin echo el sensor devuelve al microcontrolador un pulso cuyo ancho es proporcional al tiempo que tarda el sonido en viajar del transductor al obstáculo y luego de vuelta al módulo.\nCon esta función entonces indicamos el número del pin digital correspondiente al Trig y al Echo. <br> <b>hc.dist ()</b> <br> Esta función devuelve el valor de la distancia en centímetros.",
        "Imagen": "",
        "Pasos": [
          {
            "Descripción": "<br> <b> Diagrama de flujo  </b> <br> ",
            "Imagen": "images/Taller0/paso1ServoPotenciometro.jpg"
          },
          {
            "Descripción": "<br> <b> Instrucciones para armar la estructura </b> </br> &bull; Conectar circuito de energía a riel lateral del breadboard.<br> a. Conectar la salida de 5V al riel marcado como positivo en el breadboard.<br> b. Conectar cualquiera de las tres tierras (GRND) al riel marcado como negativo en el breadboard.<br> &bull; Conectar el servo al Arduino. <br> a. Conectar el cable central al riel de 5V.<br> b. Conectar el cable lateral con color más opaco a la tierra.<br> c. Conectar el cable restante a un pin digital (en el caso del ejemplo al pin 10).<br> &bull; Conectar el sensor ultrasónico.<br> a. Los pines marcados como Vcc y Grd deben ser conectados a los rieles de 5V y tierra respectivamente. <br> b. Los dos pines centrales (Trig y Echo) deben conectarse a dos pines digitales (en el caso del ejemplo, Trig al pin 7 y Echo al pin 6).\n",
            "Imagen": ""
          },
          {
            "Descripción": "<br> <b> Esquema de conexiones eléctricas </b> </br> ",
            "Imagen": "images/Taller0/paso3ServoDistancia.png"
          },
          {
            "Descripción": "<br> <b> Código en Arduino IDE </b> </br> #include <HCSR04.h>\n#include <Servo.h>\nHCSR04 hc (7, 6);\nServo servo;\nfloat Distancia = 0;\nfloat Grados = 0;\n\nvoid setup () { \n\tservo.attach (11);\n}\n\n/*\nlas decisiones if () “Si…” son para que el sensor trabaje en un rango apropiado de entre 3 y 22 centímetros\n*/\n\nvoid loop () {\n\tDistancia = hc.dist ();\n\tif (Distancia < 22) {\n\t\tif (Distancia > 3) {\n\t\t\tGrados = map (Distancia, 4, 22, 0, 180);\n\t\t\tservo.write (Grados);\n\t\t}\n\t}\n}\n",
            "Imagen": ""
          },
          {
            "Descripción": "<br> <b> Código en Bitbloq </b> </br> ",
            "Imagen": "images/Taller0/paso4ServoDistancia.png"
          }
        ]
      }
    ]
  }
}